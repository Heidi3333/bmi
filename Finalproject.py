# -*- coding: utf-8 -*-
"""Final Project

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ejaVk3JrcBaE8lGU3qMo8ONwFKUr1xMz
"""
import joblib
import pandas as pd
from sklearn.preprocessing import MinMaxScaler
import seaborn as sns
import matplotlib.pyplot as plt
from streamlit import components
from sklearn.impute import SimpleImputer
import pandas as pd
import xgboost as xgb
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import accuracy_score, confusion_matrix

data = pd.read_csv("mock_fashion_data_uk_us.csv")

print(data.head())

print(data.info())

print(data.describe())

print(data.isnull().sum())

data = data.drop_duplicates()

z_score_threshold = 3
data = data[(data['Price'] - data['Price'].mean()) / data['Price'].std() < z_score_threshold]

data['Review Sentiment'] = data['Rating'].apply(lambda x: 'Positive' if x > 3 else 'Negative')

data.to_csv("preprocessed_data.csv", index=False)

category_counts = data['Category'].value_counts()
plt.figure(figsize=(10, 6))
sns.barplot(x=category_counts.index, y=category_counts.values)
plt.title('Category Distribution')
plt.xlabel('Category')
plt.ylabel('Count')
plt.xticks(rotation=45)
plt.show()

plt.figure(figsize=(8, 6))
sns.scatterplot(x='Price', y='Rating', data=data)
plt.title('Price vs. Rating')
plt.xlabel('Price')
plt.ylabel('Rating')
plt.show()

plt.figure(figsize=(8, 6))
sns.histplot(data['Rating'], bins=10)
plt.title('Rating Distribution')
plt.xlabel('Rating')
plt.ylabel('Count')
plt.show()

plt.figure(figsize=(10, 6))
sns.boxplot(x='Category', y='Rating', data=data)
plt.title('Rating by Category')
plt.xlabel('Category')
plt.ylabel('Rating')
plt.xticks(rotation=45)
plt.show()

magazine_counts = data['Fashion Magazines'].value_counts()
plt.figure(figsize=(8, 8))
plt.pie(magazine_counts.values, labels=magazine_counts.index, autopct='%1.1f%%')
plt.title('Fashion Magazine Distribution')
plt.show()

continuous_vars = ['Price', 'Rating', 'Review Count', 'Age']
corr_matrix = data[continuous_vars].corr()
plt.figure(figsize=(10, 8))
sns.heatmap(corr_matrix, annot=True, cmap='coolwarm', square=True)
plt.title('Correlation Matrix of Continuous Variables')
plt.show()

features= data[['Rating', 'Category', 'feedback']]
target= data['Style Attributes']

# Convert categorical features to numerical using one-hot encoding
features_encoded = pd.get_dummies(features)

# Encode the categorical target variable
label_encoder = LabelEncoder()
target_encoded = label_encoder.fit_transform(target)

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(features_encoded, target_encoded, test_size=0.2, random_state=42)

# Train the XGBoost model
model = xgb.XGBClassifier()
model.fit(X_train, y_train)

# Make predictions on the test set
y_pred = model.predict(X_test)

# Decode the predicted labels
y_pred_decoded = label_encoder.inverse_transform(y_pred)

# Evaluate the model's performance
accuracy = accuracy_score(y_test, y_pred)
print("Accuracy:", accuracy)

# Train the XGBoost model using the Scikit-learn API
model = xgb.XGBClassifier()
model.fit(X_train, y_train)

# Save the trained model using joblib
joblib.dump(model, 'xgboost_model.joblib')
# Load the XGBoost model using joblib
model = joblib.load('xgboost_model.joblib')
# Train the XGBoost model
model = xgb.XGBRegressor()
model.fit(X_train, y_train)
# Convert the XGBoost model to the raw booster format
booster = model.get_booster()
# Save the raw booster model in a compatible format
booster.save_model('xgboost_model.bin')
import streamlit as st
import xgboost as xgb
import pandas as pd
from sklearn.preprocessing import LabelEncoder


# Load the pre-trained XGBoost model
model = xgb.Booster()
model.load_model('xgboost_model.bin')

# Load the label encoder
label_encoder = LabelEncoder()
label_encoder.classes_ = ['Footwear', 'Tops', 'Bottoms', 'Outerwear', 'Accessories', 'Dresses', 'Swimwear', 'Activewear', 'Lingerie']

# Define a function to make predictions with the loaded model
def predict_style_attributes(rating, category, feedback):
    # Preprocess the input features
    category_encoded = label_encoder.transform([category])[0]
    input_data = pd.DataFrame({'Rating': [rating], 'Category': [category_encoded], 'feedback': [feedback]})

    # Make predictions
    dtest = xgb.DMatrix(input_data)
    predictions = model.predict(dtest)

    # Return the predicted style attributes
    return predictions[0]

# Create the Streamlit app
def main():
    # Set page title and description
    st.set_page_config(page_title="Model Deployment and Monitoring", page_icon="ðŸŽ¨", layout="centered")

    # Display app title and description
    st.title("Fashion Style Attributes Prediction")
    st.write("Welcome to the Fashion Style Attributes Prediction app!")

    # Add input elements to get user's input
    rating = st.slider('Rating', min_value=1, max_value=5, step=1)
    category = st.selectbox('Category', ['Footwear', 'Tops', 'Bottoms', 'Outerwear', 'Accessories', 'Dresses', 'Swimwear', 'Activewear', 'Lingerie'])
    feedback = st.text_input('Feedback')

    # When the user clicks the 'Predict' button, make predictions and display the result
    if st.button('Predict'):
        with st.spinner('Predicting...'):
            style_attributes = predict_style_attributes(rating, category, feedback)
            st.success('Predicted Style Attributes: {}'.format(style_attributes))

if __name__ == '__main__':
    main()